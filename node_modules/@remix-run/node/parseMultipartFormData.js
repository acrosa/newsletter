/**
 * @remix-run/node v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var stream = require('stream');
var Busboy = require('busboy');
var formData = require('./formData.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Busboy__default = /*#__PURE__*/_interopDefaultLegacy(Busboy);

function parseMultipartFormData(request, uploadHandler) {
  return request.formData(uploadHandler);
}
async function internalParseFormData(contentType, body, abortController, uploadHandler) {
  let formData$1 = new formData.FormData();
  let fileWorkQueue = [];
  let stream$1;

  if (typeof body === "string" || Buffer.isBuffer(body)) {
    stream$1 = stream.Readable.from(body.toString());
  } else {
    stream$1 = body;
  }

  await new Promise(async (resolve, reject) => {
    let busboy = new Busboy__default["default"]({
      highWaterMark: 2 * 1024 * 1024,
      headers: {
        "content-type": contentType
      }
    });
    let aborted = false;

    function abort(error) {
      if (aborted) return;
      aborted = true;
      stream$1.unpipe();
      stream$1.removeAllListeners();
      busboy.removeAllListeners();
      abortController === null || abortController === void 0 ? void 0 : abortController.abort();
      reject(error || new Error("failed to parse form data"));
    }

    busboy.on("field", (name, value) => {
      formData$1.append(name, value);
    });
    busboy.on("file", (name, filestream, filename, encoding, mimetype) => {
      if (uploadHandler) {
        fileWorkQueue.push((async () => {
          try {
            let value = await uploadHandler({
              name,
              stream: filestream,
              filename,
              encoding,
              mimetype
            });

            if (typeof value !== "undefined") {
              formData$1.append(name, value);
            }
          } catch (error) {
            // Emit error to busboy to bail early if possible
            busboy.emit("error", error); // It's possible that the handler is doing stuff and fails
            // *after* busboy has finished. Rethrow the error for surfacing
            // in the Promise.all(fileWorkQueue) below.

            throw error;
          } finally {
            filestream.resume();
          }
        })());
      } else {
        filestream.resume();
      }

      if (!uploadHandler) {
        console.warn(`Tried to parse multipart file upload for field "${name}" but no uploadHandler was provided.` + " Read more here: https://remix.run/api/remix#parseMultipartFormData-node");
      }
    });
    stream$1.on("error", abort);
    stream$1.on("aborted", abort);
    busboy.on("error", abort);
    busboy.on("finish", resolve);
    stream$1.pipe(busboy);
  });
  await Promise.all(fileWorkQueue);
  return formData$1;
}

exports.internalParseFormData = internalParseFormData;
exports.parseMultipartFormData = parseMultipartFormData;

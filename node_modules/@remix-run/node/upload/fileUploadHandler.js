/**
 * @remix-run/node v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crypto = require('crypto');
var fs = require('fs');
var fsp = require('fs/promises');
var os = require('os');
var path = require('path');
var meter = require('./meter.js');

let defaultFilePathResolver = ({
  filename
}) => {
  let ext = filename ? path.extname(filename) : "";
  return "upload_" + crypto.randomBytes(4).readUInt32LE(0) + ext;
};

async function uniqueFile(filepath) {
  let ext = path.extname(filepath);
  let uniqueFilepath = filepath;

  for (let i = 1; await fsp.stat(uniqueFilepath).then(() => true).catch(() => false); i++) {
    uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${new Date().getTime()}${ext}`;
  }

  return uniqueFilepath;
}

function createFileUploadHandler({
  directory = os.tmpdir(),
  avoidFileConflicts = true,
  file = defaultFilePathResolver,
  filter,
  maxFileSize = 3000000
}) {
  return async ({
    name,
    stream,
    filename,
    encoding,
    mimetype
  }) => {
    if (filter && !(await filter({
      filename,
      encoding,
      mimetype
    }))) {
      stream.resume();
      return;
    }

    let dir = typeof directory === "string" ? directory : directory({
      filename,
      encoding,
      mimetype
    });

    if (!dir) {
      stream.resume();
      return;
    }

    let filedir = path.resolve(dir);
    let path$1 = typeof file === "string" ? file : file({
      filename,
      encoding,
      mimetype
    });

    if (!path$1) {
      stream.resume();
      return;
    }

    let filepath = path.resolve(filedir, path$1);

    if (avoidFileConflicts) {
      filepath = await uniqueFile(filepath);
    }

    await fsp.mkdir(path.dirname(filepath), {
      recursive: true
    }).catch(() => {});
    let meter$1 = new meter.Meter(name, maxFileSize);
    await new Promise((resolve, reject) => {
      let writeFileStream = fs.createWriteStream(filepath);
      let aborted = false;

      async function abort(error) {
        if (aborted) return;
        aborted = true;
        stream.unpipe();
        meter$1.unpipe();
        stream.removeAllListeners();
        meter$1.removeAllListeners();
        writeFileStream.removeAllListeners();
        await fsp.rm(filepath, {
          force: true
        }).catch(() => {});
        reject(error);
      }

      stream.on("error", abort);
      meter$1.on("error", abort);
      writeFileStream.on("error", abort);
      writeFileStream.on("finish", resolve);
      stream.pipe(meter$1).pipe(writeFileStream);
    });
    return new NodeOnDiskFile(filepath, meter$1.bytes, mimetype);
  };
}
class NodeOnDiskFile {
  lastModified = 0;
  webkitRelativePath = "";

  constructor(filepath, size, type) {
    this.filepath = filepath;
    this.size = size;
    this.type = type;
    this.name = path.basename(filepath);
  }

  async arrayBuffer() {
    let stream = fs.createReadStream(this.filepath);
    return new Promise((resolve, reject) => {
      const buf = [];
      stream.on("data", chunk => buf.push(chunk));
      stream.on("end", () => resolve(Buffer.concat(buf)));
      stream.on("error", err => reject(err));
    });
  }

  slice(start, end, contentType) {
    throw new Error("Method not implemented.");
  }

  stream() {
    return fs.createReadStream(this.filepath);
  }

  text() {
    return fsp.readFile(this.filepath, "utf-8");
  }

}

exports.NodeOnDiskFile = NodeOnDiskFile;
exports.createFileUploadHandler = createFileUploadHandler;

/**
 * @remix-run/node v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function isBlob(value) {
  return typeof value === "object" && (typeof value.arrayBuffer === "function" || typeof value.size === "number" || typeof value.slice === "function" || typeof value.stream === "function" || typeof value.text === "function" || typeof value.type === "string");
}

function isFile(blob) {
  let file = blob;
  return typeof file.name === "string";
}

class NodeFormData {
  constructor(form) {
    if (typeof form !== "undefined") {
      throw new Error("Form data on the server is not supported.");
    }

    this._fields = {};
  }

  append(name, value, fileName) {
    if (typeof value !== "string" && !isBlob(value)) {
      throw new Error("formData.append can only accept a string or Blob");
    }

    this._fields[name] = this._fields[name] || [];

    if (typeof value === "string" || isFile(value)) {
      this._fields[name].push(value);
    } else {
      this._fields[name].push(new File([value], fileName || "unknown"));
    }
  }

  delete(name) {
    delete this._fields[name];
  }

  get(name) {
    let arr = this._fields[name];
    return (arr === null || arr === void 0 ? void 0 : arr.slice(-1)[0]) || null;
  }

  getAll(name) {
    let arr = this._fields[name];
    return arr || [];
  }

  has(name) {
    return name in this._fields;
  }

  set(name, value, fileName) {
    if (typeof value !== "string" && !isBlob(value)) {
      throw new Error("formData.set can only accept a string or Blob");
    }

    if (typeof value === "string" || isFile(value)) {
      this._fields[name] = [value];
    } else {
      this._fields[name] = [new File([value], fileName || "unknown")];
    }
  }

  forEach(callbackfn, thisArg) {
    Object.entries(this._fields).forEach(([name, values]) => {
      values.forEach(value => callbackfn(value, name, thisArg), thisArg);
    });
  }

  entries() {
    return Object.entries(this._fields).reduce((entries, [name, values]) => {
      values.forEach(value => entries.push([name, value]));
      return entries;
    }, []).values();
  }

  keys() {
    return Object.keys(this._fields).values();
  }

  values() {
    return Object.entries(this._fields).reduce((results, [name, values]) => {
      values.forEach(value => results.push(value));
      return results;
    }, []).values();
  }

  *[Symbol.iterator]() {
    yield* this.entries();
  }

}

exports.FormData = NodeFormData;
exports.isFile = isFile;

/**
 * @remix-run/node v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var stream = require('stream');
var FormStream = require('form-data');
var nodeFetch = require('node-fetch');
var formData = require('./formData.js');
var parseMultipartFormData = require('./parseMultipartFormData.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var FormStream__default = /*#__PURE__*/_interopDefaultLegacy(FormStream);
var nodeFetch__default = /*#__PURE__*/_interopDefaultLegacy(nodeFetch);

function formDataToStream(formData$1) {
  let formStream = new FormStream__default["default"]();

  function toNodeStream(input) {
    // The input is either a Node stream or a web stream, if it has
    //  a `on` method it's a node stream so we can just return it
    if (typeof (input === null || input === void 0 ? void 0 : input.on) === "function") {
      return input;
    }

    let passthrough = new stream.PassThrough();
    let stream$1 = input;
    let reader = stream$1.getReader();
    reader.read().then(async ({
      done,
      value
    }) => {
      while (!done) {
        passthrough.push(value);
        ({
          done,
          value
        } = await reader.read());
      }

      passthrough.push(null);
    }).catch(error => {
      passthrough.emit("error", error);
    });
    return passthrough;
  }

  for (let [key, value] of formData$1.entries()) {
    if (typeof value === "string") {
      formStream.append(key, value);
    } else if (formData.isFile(value)) {
      let stream = toNodeStream(value.stream());
      formStream.append(key, stream, {
        filename: value.name,
        contentType: value.type,
        knownLength: value.size
      });
    } else {
      let file = value;
      let stream = toNodeStream(file.stream());
      formStream.append(key, stream, {
        filename: "unknown"
      });
    }
  }

  return formStream;
}

class NodeRequest extends nodeFetch.Request {
  constructor(input, init) {
    var _init;

    if (((_init = init) === null || _init === void 0 ? void 0 : _init.body) instanceof formData.FormData) {
      init = { ...init,
        body: formDataToStream(init.body)
      };
    }

    super(input, init);
    let anyInput = input;
    let anyInit = init;
    this.abortController = (anyInput === null || anyInput === void 0 ? void 0 : anyInput.abortController) || (anyInit === null || anyInit === void 0 ? void 0 : anyInit.abortController);
  }

  async formData(uploadHandler) {
    let contentType = this.headers.get("Content-Type");

    if (contentType) {
      return await parseMultipartFormData.internalParseFormData(contentType, this.body, this.abortController, uploadHandler);
    }

    throw new Error("Invalid MIME type");
  }

  clone() {
    return new NodeRequest(this);
  }

}
/**
 * A `fetch` function for node that matches the web Fetch API. Based on
 * `node-fetch`.
 *
 * @see https://github.com/node-fetch/node-fetch
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
 */

function fetch(input, init) {
  var _init2;

  init = {
    compress: false,
    ...init
  };

  if (((_init2 = init) === null || _init2 === void 0 ? void 0 : _init2.body) instanceof formData.FormData) {
    init = { ...init,
      body: formDataToStream(init.body)
    };
  } // Default to { compress: false } so responses can be proxied through more
  // easily in loaders. Otherwise the response stream encoding will not match
  // the Content-Encoding response header.


  return nodeFetch__default["default"](input, init);
}

Object.defineProperty(exports, 'Headers', {
  enumerable: true,
  get: function () { return nodeFetch.Headers; }
});
Object.defineProperty(exports, 'Response', {
  enumerable: true,
  get: function () { return nodeFetch.Response; }
});
exports.Request = NodeRequest;
exports.fetch = fetch;
